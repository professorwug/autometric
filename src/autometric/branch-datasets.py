# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/library/branch-datasets.ipynb.

# %% auto 0
__all__ = ['Stick', 'Branch', 'create_branch_battery', 'BranchBattery']

# %% ../../nbs/library/branch-datasets.ipynb 3
from fastcore.all import *
from diffusion_curvature.random_surfaces import random_polynomial
import sympy as sp

class Stick():
    def __init__(
        self,
        dimension,
        degree,
        start_point,
        time_range = 1
    ):
        store_attr()
        # construct a unique polynomial for yourself
        x = sp.symbols('x')
        p = random_polynomial(
            [x],degree
        )
        self.polynomial = p
        self.polynomial_np = sp.lambdify([x], self.polynomial, "numpy")

        # random direction for polynomial, scaled to unit length
        self.direction = np.random.randn(self.dimension)
        self.direction /= np.linalg.norm(self.direction)

    def sample_at_time(self,t):
        return self.polynomial_np(self.direction*t) + self.start_point

    def end_point(self):
        return self.sample_at_time(self.time_range)

    def sample(self, n_samples):
        ts = np.random.rand(n_samples)*self.time_range
        Xs = [self.sample_at_time(t) for t in ts]
        return np.array(Xs)
        
    def length(self):
        # integrate the polynomial over the time range
        # using sympy
        x = sp.symbols('x')
        # path length integrand
        integrand = sp.sqrt(1 + sp.diff(self.polynomial, x)**2)
        integral = sp.integrate(
            integrand, (x, 0, self.time_range))
        return float(integral)

# %% ../../nbs/library/branch-datasets.ipynb 6
import random
import numpy as np
import torch
class Branch():
    def __init__(
        self,
        dimension,
        polynomial_degree=4,
        max_branches=5,
        path_length = 5,
        seed = None,
    ):
        store_attr()
        if seed is not None:
            torch.manual_seed(seed)
            np.random.seed(seed)
            random.seed(seed)

        self.sticks = [
            Stick(
                dimension,
                polynomial_degree,
                np.zeros(dimension)
            )
        ]
        self.branching_nums = [np.random.randint(1,max_branches)]
        self.num_branches_per_point = []
        self.branch_lengths = []

        stick_idx = 0
        for i in range(path_length):
            # go through all sticks after stick_idx and create new sticks at their ends
            new_stick_idx =len(self.sticks)
            for j in range(stick_idx,len(self.sticks)):
                num_new_sticks = self.branching_nums[j]
                for k in range(num_new_sticks):
                    # create a stick
                    stick = Stick(
                        dimension,
                        polynomial_degree,
                        self.sticks[j].end_point(),
                    )
                    self.sticks.append(stick)
                    self.branching_nums.append(
                        np.random.randint(1,max_branches)
                    )
            stick_idx = new_stick_idx
        self.branching_nums = np.array(self.branching_nums)

    def sample(self,n_samples=5000):
        Xs = []
        samples_per_stick = n_samples // len(self.sticks)
        for i, stick in enumerate(self.sticks):
            Xs.append(np.vstack([stick.sample(samples_per_stick-1),stick.end_point()]))
            self.num_branches_per_point.append(np.append(np.zeros(n_samples-1), self.branching_nums[i]))
            self.branch_lengths.append(
                np.ones(samples_per_stick)*stick.length()
            )
        self.num_branches_per_point = np.concatenate(self.num_branches_per_point)
        self.branch_lengths = np.concatenate(self.branch_lengths)
        return np.concatenate(Xs,axis=0)

# %% ../../nbs/library/branch-datasets.ipynb 10
from tqdm.auto import tqdm
import h5py

def create_branch_battery(
    dimensions,
    num_samples,
    max_branches,
    path_lengths,
    num_branches_per_config,
    outfile,
):
    if os.path.exists(outfile):
        return h5py.File(outfile,'a')
    f = h5py.File(outfile,'a')
    BIGLIST = []
    for d in tqdm(dimensions):
        for n in num_samples:
            for m in max_branches:
                for p in path_lengths:
                    for i in range(num_branches_per_config):
                        branch = Branch(dimension=d, max_branches=m, path_length=p)
                        X = branch.sample(n)
                        # save this information to an h5py datafile
                        branch_group = f.create_group(f"branch_{d}_{n}_{m}_{p}_{i}")
                        samples = branch_group.create_dataset("samples", X.shape, dtype='f')
                        samples[...] = X
                        branches_per_point = branch_group.create_dataset("num_branches_per_point", branch.num_branches_per_point.shape, dtype='f')
                        branches_per_point[...] = branch.num_branches_per_point
                        branching_nums = branch_group.create_dataset("branching_nums", branch.branching_nums.shape, dtype='f')
                        branching_nums[...] = branch.branching_nums
                        branch_lengths = branch_group.create_dataset("branch_lengths", branch.branch_lengths.shape, dtype='f')
                        branch_lengths[...] = branch.branch_lengths
                        # add metadata to the group
                        branch_group.attrs['num_sticks'] = len(branch.sticks)
                        branch_group.attrs['num_samples'] = n
                        branch_group.attrs['max_branches'] = m
                        branch_group.attrs['path_length'] = p
                        branch_group.attrs['dimension'] = d
    return f


# %% ../../nbs/library/branch-datasets.ipynb 19
import h5py
class BranchBattery():
    def __init__(self, data_path = "../data/branch_battery.h5"):
        self.data_path = data_path
        self.BB = h5py.File(data_path,'r')
        self.keys = list(self.BB.keys())
    def __iter__(self):
        return self
    def __next__(self):
        if len(self.keys) == 0:
            raise StopIteration
        else:
            key = self.keys.pop()
            return self.BB[key]
