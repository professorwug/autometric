# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/library/triangle-condition-curvature.ipynb.

# %% auto 0
__all__ = ['create_triangles_from_pointcloud', 'get_geodesics_from_triangle', 'plot_triangle_in_3d', 'euclidean_section_length',
           'alexandrov_curvature_of_triangle', 'compute_triangle_curvatures']

# %% ../../nbs/library/triangle-condition-curvature.ipynb 7
import numpy as np
# def create_triangles_from_pointcloud(
#     X:np.ndarray, 
#     D:np.ndarray, # manifold distance matrix of X; shape (num_points, num_points).
#     min_dist:float=0.1, # triangle edges must length greater than this
#     num_triangles=100,
#     ):
#     """
#     Create a set of triangles from a pointcloud. This is not a mesh; just a set of triangles with edge lengths around min_dist.
#     Returns np.ndarray of shape (num_triangles, 3). Each row is a triangle; each entry is an index in X.
#     """
#     # subsample num_triangles points from X
#     idxs = np.random.choice(X.shape[0], num_triangles, replace=False)
#     # for each idx, construct one triangle by matching two points - both of which have distances greater than min_dist
#     sub_D = D[idxs]
#     triangles = []
#     for i in range(num_triangles):
#         # find two points with distances greater than min_dist
#         idxs = np.where(sub_D[i,:] > min_dist)[0]
#         if len(idxs) == 0:
#             continue
#         # find the two points with the smallest distance
#         idxs = idxs[np.argsort(sub_D[i,idxs])]
#         # add the two points to the triangle
#         triangles.append([idxs[0], idxs[1], idxs[2]])
#     return np.array(triangles)

def create_triangles_from_pointcloud(
    X:np.ndarray, 
    D:np.ndarray, # manifold distance matrix of X; shape (num_points, num_points).
    min_dist:float=0.1, # triangle edges must length greater than this
    max_dist:float=0.3,
    num_triangles=100,
    hypotenuse_less_than = 1.7, # the hypotenuse times this should be less than the sum of the other two sides
    ):
    triangles = []
    while len(triangles) < num_triangles:
        candidate_idxs = np.random.choice(X.shape[0], num_triangles, replace=False)
        for a in candidate_idxs:
            # find idxs of points with distances greater than min_dist from a
            idxs = np.where((D[a,:] > min_dist) & (D[a,:] < max_dist))[0]
            if len(idxs) == 0:
                continue
            # sort by distance from a
            idxs = idxs[np.argsort(D[a,idxs])]
            for b in idxs:
                # find idxs of points with distances greater than min_dist from b and a
                idxs = np.where((D[b,:] > min_dist) & (D[b,:] < max_dist) & (D[a,:] > min_dist) & (D[a,:] < max_dist) & ((D[a, :] + D[b,:]) > hypotenuse_less_than*D[a,b]))[0]
                if len(idxs) == 0:
                    continue
                else:
                    # sort by distance from a and b
                    idxs = idxs[np.argsort(D[b,idxs] + D[a,idxs])]
                    if isinstance(idxs, int): idxs = [idxs]
                    for c in idxs:
                        if (D[a, b] + D[b,c]) > hypotenuse_less_than*D[a,c] and (D[a, c] + D[a, b]) > hypotenuse_less_than*D[b,c]:
                            triangles.append([a, b, c])
                            break
                    break
    return np.array(triangles)[:num_triangles]

# %% ../../nbs/library/triangle-condition-curvature.ipynb 11
def get_geodesics_from_triangle(geodesic_fn, X, triangle_idxs, t = np.linspace(0,1,100)):
    start_idxs = [triangle_idxs[0], triangle_idxs[0], triangle_idxs[1]]
    end_idxs = [triangle_idxs[1], triangle_idxs[2], triangle_idxs[2]]
    start_points = torch.tensor(X[start_idxs])
    end_points = torch.tensor(X[end_idxs])
    points, lengths = geodesic_fn(start_points, end_points, t)
    return points, lengths

# %% ../../nbs/library/triangle-condition-curvature.ipynb 12
from .utils import plot_3d_with_geodesics
def plot_triangle_in_3d(X, triangle_idxs, geodesic_fn):
    gs, lengths = get_geodesics_from_triangle(geodesic_fn, X, triangle_idxs)
    plot_3d_with_geodesics(X, gs, title=f"Triangle {triangle_idxs}")
    

# %% ../../nbs/library/triangle-condition-curvature.ipynb 15
def euclidean_section_length(
    a, # length from b' to c'
    b, # length from c' to a'
    c, # length from a' to b'
    c1 # length from b' to midpoint
    ):
    # computes the euclidean length of an edge running from vertex c' to a midpoint c1 on edge opposite
    inner = c1**2 + a**2 + c1*((b**2 - a**2 - c**2)/c)
    return inner**0.5
    # computes the euclidean length of an edge running from vertex c' to a midpoint on the edge opposite, c1

def alexandrov_curvature_of_triangle(X, triangle_idxs, geodesic_fn, return_extras = False):
    gs, lengths = get_geodesics_from_triangle(
        geodesic_fn, X, triangle_idxs
    )
    # three lengths are a, b, c. 
    a = lengths[0]
    b = lengths[1]
    c = lengths[2]
    # choose midpoint in third geodesic
    midpoint = gs[2][len(gs[2])//2]
    (c1_geodesic, d_geodesic), (c1, d) = geodesic_fn(X[[triangle_idxs[1], triangle_idxs[0]]], np.vstack([midpoint, midpoint]), np.linspace(0,1,100))
    d_euclidean = euclidean_section_length(a, b, c, c1)
    k = d - d_euclidean
    if return_extras:
        return k, gs, c1_geodesic, d_geodesic
    else:
        return k

# %% ../../nbs/library/triangle-condition-curvature.ipynb 24
def compute_triangle_curvatures(X:np.ndarray, # pointcloud
                                D:np.ndarray, # distances on pointcloud; preferable manifold distances (PHATE). Used for creating triangles. Doesn't need to come from the geodesics.
                                geodesic_fn, # function that takes start_points, end_points and ts and returns (a list of geodesics, length of each geodesic)
                                num_triangles = 100, 
                                min_edge_length = 1,  # Must tune to each dataset. Defaults for torus.
                                max_edge_length = 1.5,
                                ):
    """Compures the Alexandrov curvature of sampled triangles. Returns ks, middle_idxs; ks is a list of Alexandrov curvatures, and middle_idxs is a list of the indices of the middle point of each triangle."""
    triangles = create_triangles_from_pointcloud(X, D, min_edge_length, max_edge_length, num_triangles)
    ks = []
    middle_idxs = []
    for t in tqdm(triangles):
        k, gs, c1_geodesic, d_geodesic = alexandrov_curvature_of_triangle(X, t, geodesic_fn, return_extras = True)
        ks.append(k)
        middle_idxs.append(d_geodesic[len(d_geodesic)//2])
    return ks, middle_idxs
